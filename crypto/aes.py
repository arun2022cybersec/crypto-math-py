from group_theory.galois_field import GaloisField

class AES(GaloisField):
    """Represents the AES (Advanced Encryption Standard) algorithm using Galois fields."""

    def __init__(self, elements, addition, multiplication):
        """
        Initialize the AES algorithm with elements, addition, and multiplication operations.

        Args:
            elements (set): The set of elements in the Galois field.
            addition (callable): The addition operation for the Galois field.
            multiplication (callable): The multiplication operation for the Galois field.
        """
        super().__init__(elements, addition, multiplication)
        self.Nb = 4  # Number of columns (32-bit words) comprising the State. For AES, Nb = 4.
        self.Nk = 4  # Number of 32-bit words comprising the Cipher Key. For AES-128, Nk = 4.
        self.Nr = 10  # Number of rounds, which is a function of Nk and Nb (which is fixed). For AES-128, Nr = 10.
        self.s_box = [
            # S-box values
            0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
            0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
            0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
            0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
            0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
            0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
            0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
            0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
            0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
            0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
            0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
            0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
            0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
            0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
            0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
            0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
        ]
        self.inv_s_box = [
            # Inverse S-box values
            0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
        ]
        self.rcon = [
            # Rcon values
            0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36
        ]

    def key_expansion(self, key):
        """
        Perform key expansion to generate round keys.

        Args:
            key (list): The cipher key.

        Returns:
            list: The expanded key schedule.
        """
        # Key expansion logic
        def sub_word(word):
            return [self.s_box[b] for b in word]

        def rot_word(word):
            return word[1:] + word[:1]

        w = [0] * (self.Nb * (self.Nr + 1))
        for i in range(self.Nk):
            w[i] = key[4 * i: 4 * (i + 1)]

        for i in range(self.Nk, self.Nb * (self.Nr + 1)):
            temp = w[i - 1]
            if i % self.Nk == 0:
                temp = sub_word(rot_word(temp))
                temp[0] ^= self.rcon[i // self.Nk]
            elif self.Nk > 6 and i % self.Nk == 4:
                temp = sub_word(temp)
            w[i] = [w[i - self.Nk][j] ^ temp[j] for j in range(4)]
        return w

    def encrypt(self, plaintext, key):
        """
        Encrypt the plaintext using the provided key.

        Args:
            plaintext (list): The plaintext to encrypt.
            key (list): The encryption key.

        Returns:
            list: The encrypted ciphertext.
        """
        # Encryption logic
        state = [plaintext[i:i + 4] for i in range(0, len(plaintext), 4)]
        round_keys = self.key_expansion(key)

        def add_round_key(state, round_key):
            return [[state[i][j] ^ round_key[i][j] for j in range(4)] for i in range(4)]

        def sub_bytes(state):
            return [[self.s_box[b] for b in row] for row in state]

        def shift_rows(state):
            return [state[0], state[1][1:] + state[1][:1], state[2][2:] + state[2][:2], state[3][3:] + state[3][:3]]

        def mix_columns(state):
            def mix_single_column(column):
                return [
                    self.galois_mult(column[0], 2) ^ self.galois_mult(column[1], 3) ^ column[2] ^ column[3],
                    column[0] ^ self.galois_mult(column[1], 2) ^ self.galois_mult(column[2], 3) ^ column[3],
                    column[0] ^ column[1] ^ self.galois_mult(column[2], 2) ^ self.galois_mult(column[3], 3),
                    self.galois_mult(column[0], 3) ^ column[1] ^ column[2] ^ self.galois_mult(column[3], 2)
                ]
            return [mix_single_column(col) for col in zip(*state)]

        state = add_round_key(state, round_keys[:self.Nb])
        for round in range(1, self.Nr):
            state = sub_bytes(state)
            state = shift_rows(state)
            state = mix_columns(state)
            state = add_round_key(state, round_keys[round * self.Nb:(round + 1) * self.Nb])
        state = sub_bytes(state)
        state = shift_rows(state)
        state = add_round_key(state, round_keys[self.Nr * self.Nb:])
        return [byte for row in state for byte in row]

    def decrypt(self, ciphertext, key):
        """
        Decrypt the ciphertext using the provided key.

        Args:
            ciphertext (list): The ciphertext to decrypt.
            key (list): The decryption key.

        Returns:
            list: The decrypted plaintext.
        """
        # Decryption logic
        state = [ciphertext[i:i + 4] for i in range(0, len(ciphertext), 4)]
        round_keys = self.key_expansion(key)

        def add_round_key(state, round_key):
            return [[state[i][j] ^ round_key[i][j] for j in range(4)] for i in range(4)]

        def inv_sub_bytes(state):
            return [[self.inv_s_box[b] for b in row] for row in state]

        def inv_shift_rows(state):
            return [state[0], state[1][-1:] + state[1][:-1], state[2][-2:] + state[2][-2], state[3][-3:] + state[3][-3]]

        def inv_mix_columns(state):
            def inv_mix_single_column(column):
                return [
                    self.galois_mult(column[0], 14) ^ self.galois_mult(column[1], 11) ^ self.galois_mult(column[2], 13) ^ self.galois_mult(column[3], 9),
                    self.galois_mult(column[0], 9) ^ self.galois_mult(column[1], 14) ^ self.galois_mult(column[2], 11) ^ self.galois_mult(column[3], 13),
                    self.galois_mult(column[0], 13) ^ self.galois_mult(column[1], 9) ^ self.galois_mult(column[2], 14) ^ self.galois_mult(column[3], 11),
                    self.galois_mult(column[0], 11) ^ self.galois_mult(column[1], 13) ^ self.galois_mult(column[2], 9) ^ self.galois_mult(column[3], 14)
                ]
            return [inv_mix_single_column(col) for col in zip(*state)]

        state = add_round_key(state, round_keys[self.Nr * self.Nb:])
        for round in range(self.Nr - 1, 0, -1):
            state = inv_shift_rows(state)
            state = inv_sub_bytes(state)
            state = add_round_key(state, round_keys[round * self.Nb:(round + 1) * self.Nb])
            state = inv_mix_columns(state)
        state = inv_shift_rows(state)
        state = inv_sub_bytes(state)
        state = add_round_key(state, round_keys[:self.Nb])
        return [byte for row in state for byte in row]
